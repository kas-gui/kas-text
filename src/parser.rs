// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License in the LICENSE-APACHE file or at:
//     https://www.apache.org/licenses/LICENSE-2.0

//! Parsers for formatted text

use crate::env::Environment;
use crate::fonts::FontId;
use crate::FormattedString;

#[cfg(feature = "markdown")]
mod markdown;
#[cfg(feature = "markdown")]
pub use markdown::Markdown;

/// Text parsers
pub trait Parser {
    /// Data type containing formatting data
    type FormatData: FormatData;

    /// Generate unformatted string and formatting data
    ///
    /// This method returns unformatted text as a `String` and separate
    /// formatting data. This formatting data is usually stored as a boxed dyn
    /// trait object (see documentation on [`FormatData`]).
    fn finish(self) -> (String, Self::FormatData);
}

impl<P: Parser> From<P> for FormattedString {
    fn from(p: P) -> Self {
        let (text, fmt) = p.finish();
        let fmt = Box::new(fmt);
        FormattedString { text, fmt }
    }
}

impl From<String> for FormattedString {
    fn from(text: String) -> Self {
        let fmt = Box::new(EmptyFmtData);
        FormattedString { text, fmt }
    }
}

impl From<&str> for FormattedString {
    fn from(text: &str) -> Self {
        let text = text.to_string();
        let fmt = Box::new(EmptyFmtData);
        FormattedString { text, fmt }
    }
}

/// Formatting data associated with text
///
/// This type is generated by a [`Parser`] and contains associated data, notably
/// formatting data.
///
/// Note: this trait is always used as a dyn object and always returns a dyn
/// iterator. This allows usage in non-generic types and carries only a small
/// usage penalty (since formatting data is not accessed frequently).
/// To support generating non-dyn iterators would require use of generic
/// associated types (an unstable nightly feature) to attach the lifetime
/// restriction on the iterator or unsafe code to ignore it.
///
/// As a side-effect of the above design decision, the unformatted text is
/// stored in a separate string to allow direct access.
pub trait FormatData: std::fmt::Debug + 'static {
    /// Produce a boxed clone of self
    fn clone_boxed(&self) -> Box<dyn FormatData>;

    /// Delete sub-range
    ///
    /// If a sub-range of text is removed, this method is called to remove
    /// formatting data specific for this range and move data applying after the
    /// range forward.
    ///
    /// It is valid for `end` to exceed the length of the text (even to be
    /// `u32::MAX`).
    fn remove_range(&mut self, start: u32, end: u32);

    /// Expand a range
    ///
    /// If text is inserted, this method is called to move back formatting data
    /// applying after the insertion position. It is generally expected that the
    /// inserted text will be formatted the same as the `char` prior to the
    /// inserted text, but exact semantics are defined by the implementation.
    fn insert_range(&mut self, start: u32, len: u32);

    /// Construct an iterator over formatting items
    ///
    /// It is expected that [`Format::start`] of yielded items is strictly
    /// increasing; if not, formatting may not be applied correctly.
    ///
    /// For plain text this iterator will be empty.
    fn fmt_iter<'a>(&'a self, env: &'a Environment) -> Box<dyn Iterator<Item = Format> + 'a>;
}

#[derive(Clone, Debug)]
struct EmptyFmtData;

impl FormatData for EmptyFmtData {
    fn clone_boxed(&self) -> Box<dyn FormatData> {
        Box::new(EmptyFmtData)
    }
    fn remove_range(&mut self, _: u32, _: u32) {}
    fn insert_range(&mut self, _: u32, _: u32) {}
    fn fmt_iter<'a>(&'a self, _: &'a Environment) -> Box<dyn Iterator<Item = Format> + 'a> {
        Box::new(std::iter::empty())
    }
}

impl Clone for Box<dyn FormatData> {
    fn clone(&self) -> Self {
        (**self).clone_boxed()
    }
}

/// Formatting marker
#[derive(Clone, Debug, Default, PartialEq)]
pub struct Format {
    /// Index in text at which formatting becomes active
    ///
    /// (Note that we use `u32` not `usize` since it can be assumed text length
    /// will never exeed `u32::MAX`.)
    pub start: u32,
    /// Font identifier
    pub font_id: FontId,
    /// Font size, in dots-per-em (pixel width of an 'M')
    ///
    /// This may be calculated from point size as `pt_size * dpp`, where `dpp`
    /// is the number of pixels per point ([`Environment::dpp`]).
    pub dpem: f32,
}
